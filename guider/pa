getimages.c:/* Note: assumes 'data' is big-endian */
graph.c:  pthread_mutex_init(&g->lock,NULL); 
graph.c:  g->disp = mw->disp;
graph.c:  strcpy(g->name,nm); 
graph.c:  g->nc = nc;
graph.c:  g->m = (int*)malloc(nc*sizeof(int));
graph.c:  g->cur = (int*)malloc(nc*sizeof(int));
graph.c:  g->data = (float**)malloc(nc*sizeof(float*));
graph.c:    g->m[i] = nd;
graph.c:    g->data[i] = (float*)calloc(g->m[i],sizeof(float));
graph.c:    g->cur[i] = 0;
graph.c:  g->vmin = -1.0f;
graph.c:  g->vmax = +1.0f;
graph.c:  g->half = 1;
graph.c:  g->quarter = g->eighth = 0;
graph.c:  g->x = x;
graph.c:  g->y = y;
graph.c:  g->w = w;
graph.c:  g->h = h;
graph.c:  g->win = XCreateSimpleWindow(g->disp,parent,x,y,w,h,1,app->black,app->lgrey);
graph.c:  g->win = XCreateSimpleWindow(g->disp,parent,x,y,w,h,0,app->black,app->grey);
graph.c:  XMapRaised(g->disp,g->win);
graph.c:  CBX_SelectInput_Ext(g->disp,g->win,ExposureMask);
graph.c:  g->gfc = CBX_CreateGfC_Ext(g->disp,fn,"bold",PXh);
graph.c:  pthread_mutex_lock(&g->lock);
graph.c:  g->vmin = vmin;
graph.c:  g->vmax = vmax;
graph.c:  g->half = (flag & 0x01) ? 1 : 0;     /* show dashed line at 0.5 */
graph.c:  g->quarter = (flag & 0x02) ? 1 : 0;  /* show dashed line at 1/4 */
graph.c:  g->eighth = (flag & 0x04) ? 1 : 0;   /* show dashed line at 1/8 */
graph.c:  pthread_mutex_unlock(&g->lock);
graph.c:  fprintf(stderr,"%s(%s)\n",PREFUN,g->name);
graph.c:    if (event->xexpose.window == g->win) {
graph.c:  // if (r) fprintf(stderr,"%s(%s)\n",PREFUN,g->name);
graph.c:  Display     *disp=g->disp;
graph.c:  Window      win=g->win;
graph.c:  GC          gc=g->gfc.gc;
graph.c:  fprintf(stderr,"%s(%s)\n",PREFUN,g->name);
graph.c:  pthread_mutex_lock(&g->lock);
graph.c:  y0 = 2+PXh/3;               y1 = g->h-PXh/3;  h = (double)(y1-y0);
graph.c:  x0 = 3+PXw*strlen(g->name); x1 = g->w-PXw/3;  w = (double)(x1-x0);
graph.c:  x0 = 3+PXw;                 x1 = g->w-PXw/3;  w = (double)(x1-x0);
graph.c:  y0 = 2;                     y1 = g->h-2    ;  h = (double)(y1-y0);
graph.c:  x0 = 3+PXw;                 x1 = g->w-2    ;  w = (double)(x1-x0);
graph.c:  XDrawString(disp,win,gc,1,(y0+y1)/2+PXh/3,g->name,strlen(g->name));
graph.c:  y = (y0+y1)/2 - (PXh*strlen(g->name))/2 + 2*PXh/3;
graph.c:  for (i=0; i<strlen(g->name); i++) { 
graph.c:    XDrawString(disp,win,gc,1,y+i*PXh,g->name+i,1);
graph.c:  if (g->half) {
graph.c:  if (g->quarter) {                    /* v0355 */
graph.c:  if (g->eighth) {                     /* v0355 */
graph.c:  double vdyn = (double)(g->vmax - g->vmin);
graph.c:  for (i=0; i<g->nc; i++) {
graph.c:    double tdyn = (double)g->m[i];
graph.c:    d = g->data[i];
graph.c:    for (j=0; j<g->m[i]; j++) {
graph.c:      r = (j == g->cur[i]) ? 3 : 1;
graph.c:      y = y1 - h*(d[j]-g->vmin)/vdyn;
graph.c:  pthread_mutex_unlock(&g->lock);
graph.c:  fprintf(stderr,"%s(%s,%d,%.4f)\n",PREFUN,g->name,ch,value);
graph.c:  assert(ch < g->nc);
graph.c:  pthread_mutex_lock(&g->lock);
graph.c:  int n = (g->cur[ch]+1) % g->m[ch];
graph.c:  float *d = g->data[ch];
graph.c:  g->cur[ch] = n;
graph.c:  pthread_mutex_unlock(&g->lock);
guider.c:  g->fps = 1.0/g->status.exptime;
guider.c:  g->fwhm = 1;                         /* just a flag here */
guider.c:  g->q_flag = 0;
guider.c:  strcpy(g->tcbox.text,"tc"); CBX_UpdateEditWindow(&g->tcbox); 
guider.c:  strcpy(g->mxbox.text,"mx"); CBX_UpdateEditWindow(&g->mxbox);
guider.c:  strcpy(g->bkbox.text,"bk"); CBX_UpdateEditWindow(&g->bkbox);
guider.c:  strcpy(g->fwbox.text,"fw"); CBX_UpdateEditWindow(&g->fwbox);
guider.c:    if (g->gmode == GM_PR) {           /* gm1 */
guider.c:    switch (g->gmode) {
guider.c:      g->gid = 0;
guider.c:  g->qltool->guiding = g->update_flag = 0;
guider.c:  sprintf(g->fgbox.text,"%d",0); CBX_UpdateEditWindow(&g->fgbox);
guider.c:  sprintf(g->gdbox.text,"gd  off"); CBX_UpdateEditWindow(&g->gdbox);
guider.c:  printf("%s(%s) -- stopped)\n",PREFUN,g->name);
guider.c:  QlTool *qltool = g->qltool;
guider.c:  ZwoStruct *server = g->server;
guider.c:  while (g->loop_running && qltool->guiding) {
guider.c:      if (fwhm == 0 || (g->q_flag==2)) {  /* first (or bad) fit */
guider.c:        fwhm = g->px * get_fwhm(frame->data,frame->w,frame->h,ix,iy,
guider.c:      if (g->gmode == GM_SV5) {        /* gm5 mode v0416 */
guider.c:            n0 = g->north;             /* v0419 */
guider.c:            a0 = (qltool->arc_angle + g->parit2*g->parity*n0); // todo sign=parit2
guider.c:          if (g->north != n0) {        /* position angle changed */
guider.c:            n0 = g->north;
guider.c:            double a = (a0-(g->parit2*g->parity*n0))/RADS; // todo sign=parit2
guider.c:            qltool_redraw(g->qltool,False);
guider.c:          if (g->gmode != GM_SV5) printf("telescope dragging (%f,%f) !!!\n",gx,gy);
guider.c:        fit[4] = fwhm/(SQRLN22*g->px); /* sigma [pixels] */
guider.c:        g->q_flag = fit_star(pbuf,i,fit,400);
guider.c:        fwhm = SQRLN22*fit[4]*g->px;   /* FWHM [arcsec] */
guider.c:        if ((fwhm > 5.0) || (fwhm < 0.1)) g->q_flag = 2;  /* v0337 */
guider.c:        if ((fwhm > 5.0) || (fwhm < 0.2)) g->q_flag = 2;  /* sanity check */
guider.c:        g->q_flag = 2;
guider.c:      pthread_mutex_lock(&g->mutex);
guider.c:      g->fps = 0.8*g->fps + 0.2/(t2-t1);
guider.c:      if (g->q_flag < 2) { double azerr,elerr; /* we have valid measurement */
guider.c:        g->flux = flux;
guider.c:        g->ppix = (double)ppix;
guider.c:        g->back = back;
guider.c:        g->fwhm = fwhm;
guider.c:        g->dx = (cx-gx); 
guider.c:        g->dy = (cy-gy);
guider.c:        if (qltool->guiding < 0) graph_scale(g->g_tc,0,1.333*flux,0);
guider.c:        graph_add1(g->g_tc,flux,0);
guider.c:        graph_add1(g->g_fw,fwhm,0);
guider.c:        rotate(g->px*g->dx,g->px*g->dy,g->pa,g->parity,&azerr,&elerr);
guider.c:        graph_add1(g->g_az,azerr,0);
guider.c:        graph_add1(g->g_el,elerr,0);
guider.c:        double fdge = (g->q_flag == 0) ? 0.35 : 0.2;
guider.c:          g->azg = fdge * g->sens * azerr;
guider.c:          g->elg = fdge * g->sens * elerr;
guider.c:          g->azg  = azerr + ((server->rolling + 1.0) * (azerr - g->azerp));
guider.c:          g->azg *= fdge * g->sens;
guider.c:          g->elg  = elerr + ((server->rolling + 1.0) * (elerr - g->elerp));
guider.c:          g->elg *= fdge * g->sens;
guider.c:        g->azerp = azerr;              /* store last error */
guider.c:        g->elerp = elerr;
guider.c:          eds_send801(g->gnum,fwhm,qltool->guiding,g->dx,g->dy,flux);
guider.c:            err = telio_aeg(g->azg,g->elg); /* v0417 */
guider.c:        g->azg = g->elg = 0;
guider.c:      g->update_flag = True;           /* update GUI */
guider.c:      pthread_mutex_unlock(&g->mutex);
guider.c:  QlTool *qltool = g->qltool;
guider.c:  ZwoStruct *server = g->server;
guider.c:  while (g->loop_running && qltool->guiding) {
guider.c:      pthread_mutex_lock(&g->mutex);
guider.c:      g->fps = 0.8*g->fps + 0.2/(t2-t1);
guider.c:      g->dx = rx;                      /* use as criterion if we */
guider.c:      g->dy = ry;                      /* should send a correction */
guider.c:      graph_add1(g->g_tc,rx,0); 
guider.c:      graph_add1(g->g_fw,ry,0);
guider.c:        rotate(dx,dy,g->pa,g->parity,&azerr,&elerr);
guider.c:        graph_add1(g->g_az,azerr,0);
guider.c:        graph_add1(g->g_el,elerr,0);
guider.c:          g->azg = g->sens * azerr;
guider.c:          g->elg = g->sens * elerr;
guider.c:              if (g->gmpar == 'p') telio_gpaer(3,-g->azg,-g->elg);  /* v0354 */
guider.c:              err = telio_aeg(g->azg,g->elg);
guider.c:      g->update_flag = True;           /* update GUI */
guider.c:      pthread_mutex_unlock(&g->mutex);
guider.c:  QlTool *qltool = g->qltool;
guider.c:  ZwoStruct *server = g->server;
guider.c:  while (g->loop_running && qltool->guiding) {
guider.c:      if ((fwhm <= 0) || (g->q_flag > 1)) fwhm = 0.7;  /* default [arcsec] */
guider.c:      if ((cy <= 0) || (g->q_flag > 1)) cy = iy;
guider.c:      fit[3] = fwhm/(SQRLN22*g->px); /* sigma [pixels] */
guider.c:      g->q_flag = fit_profile4(pbuf,n,fit,3000);
guider.c:      fwhm = SQRLN22*fit[3]*g->px;   /* FWHM [arcsec] */
guider.c:      if ((fwhm > 5.0) || (fwhm < 0.1)) g->q_flag = 2; /* sanity check */
guider.c:      if ((fabs(cy-gy) > vrad) || (flux < 1*n*n))  g->q_flag = 2;
guider.c:      drx = calc_quad(vrad,g->slitW,fit[3],1.0,NULL); /* quadrant ratio */
guider.c:      (void)calc_quad(vrad,g->slitW,fit[3],dx,&scale); /* scale factor */
guider.c:      pthread_mutex_lock(&g->mutex);
guider.c:      g->fps = 0.8*g->fps + 0.2/(t2-t1);
guider.c:      if (g->q_flag < 2) {             /* ok fit */
guider.c:        g->dx = dx;                    /* [pixels] from ratio v0408 */
guider.c:        g->dy = cy-gy;                 /* [pixels] from fit */
guider.c:        g->flux = flux;
guider.c:        g->ppix = ppix;
guider.c:        g->back = back;
guider.c:        g->fwhm = fwhm;
guider.c:        if (qltool->guiding < 0) graph_scale(g->g_tc,0,1.333*flux,0x00);
guider.c:        graph_add1(g->g_tc,flux,0); 
guider.c:        graph_add1(g->g_fw,fwhm,0);
guider.c:        graph_add1(g->g_az,g->dx*g->px,0); /* graph shows [arcsec] */
guider.c:        graph_add1(g->g_el,g->dy*g->px,0);
guider.c:        ddy = (qltool->guiding < 0) ? 0.0 : g->dy-ody; /* derivative */
guider.c:        ody = g->dy;                     /* old 'dy' [pixels] */
guider.c:        dy = g->dy + (server->rolling+1.0)*ddy; /* [pixels] */
guider.c:        ddx = (qltool->guiding < 0) ? 0.0 : g->dx-odx; /* derivative */
guider.c:        odx = g->dx;                     /* old 'dx' [pixels] */
guider.c:        dx = g->dx + (server->rolling+1.0)*ddx; /* [pixels] */
guider.c:        if ((fabs(dx*g->px) > 0.05) || (fabs(dy*g->px) > 0.05)) { /* [arcsec] */
guider.c:          rotate(dx*g->px,dy*g->px,g->pa,g->parity,&azerr,&elerr);
guider.c:          // ?Povilas eds_send801(g->gnum,fwhm,qltool->guiding,g->dx,g->dy,flux);
guider.c:          double fdge = (g->q_flag == 0) ? 0.35 : 0.2;
guider.c:          g->azg = fdge * g->sens * azerr;
guider.c:          g->elg = fdge * g->sens * elerr;
guider.c:              if (g->gmpar == 'p') telio_gpaer(3,-g->azg,-g->elg); 
guider.c:              err = telio_aeg(g->azg,g->elg);
guider.c:      g->update_flag = True;           /* update GUI */
guider.c:      pthread_mutex_unlock(&g->mutex);
qltool.c:      for (i=0; i<qlt->smoothing-2; i++) {
qltool.c:        i++; if (i == qlt->smoothing-2) break;
tcpip.c:  if (i >= buflen) return E_tcpip_overflow; /* bug-fix 2017-07-03 */
zwogcam.c: * v0.317  2023-01-20  bug-fixes, add CAMERA,FRAME,ROTATORN
zwogcam.c: * v0.331  2023-07-28  rename executable, bug-fixes
zwogcam.c:    sprintf(g->name,"gCam%d",g->gnum);
zwogcam.c:    g->server = zwo_create(g->host,SERVER_PORT);
zwogcam.c:    g->gid = 0;                        /* guiding thread ID */
zwogcam.c:    g->qltool = NULL;
zwogcam.c:    g->loop_running = g->house_running = False; 
zwogcam.c:    g->stop_flag = False;
zwogcam.c:    g->init_flag = g->send_flag = g->write_flag = 0;
zwogcam.c:    pthread_mutex_init(&g->mutex,NULL);
zwogcam.c:    g->fps = g->flux = g->ppix = g->back = g->fwhm = g->dx = g->dy = 0;
zwogcam.c:    g->pa = 0.0;
zwogcam.c:    g->shmode = (g->gmode == GM_SH) ? 1 : 0;
zwogcam.c:    g->pamode = 1;                     /* v0066 */
zwogcam.c:    g->msmode = 1;
zwogcam.c:    g->sendNumber = 1;                 /* v0313 */
zwogcam.c:    strcpy(g->send_host,telio_host);
zwogcam.c:    g->send_port = 5700+g->gnum-1;     /* v0316 */
zwogcam.c:    g->stored_tf1 = 0.5f; g->stored_tf3 = 1.0f;
zwogcam.c:    g->stored_send = 0; g->stored_av = 0; g->stored_mode = 1;
zwogcam.c:    strcpy(g->lastCommand,"");
zwogcam.c:    strcpy(g->command_msg,"");
zwogcam.c:    FITSpars *st = &g->status;
zwogcam.c:    sprintf(buf,FMT_RUN,g->gnum);
zwogcam.c:    sprintf(st->prefix,"%s%d_",b,g->gnum);
zwogcam.c:    st->pixscale = g->px;              /* FITS header */
zwogcam.c:    st->ca = modulo(g->angle+180.0,0,360);  /* v0316 */
zwogcam.c:    st->camera = g->gnum;                /* v0317 */
zwogcam.c:    g->win = mwin.win;                 /* one guider window v0400 */
zwogcam.c:    Window p = g->win;                 /* parent */
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->tcbox,p,x,y,w,XXh,"tc 0");
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->mxbox,p,x,y,w,XXh,"mx 0");
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->bkbox,p,x,y,w,XXh,"bk 0");
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->fwbox,p,x,y,w,XXh,"fw 0");
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->dxbox,p,x,y,w,XXh,"dx 0");
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->dybox,p,x,y,w,XXh,"dy 0");
zwogcam.c:    x += g->tcbox.w + PXw/2;           
zwogcam.c:    y  = g->tcbox.y;
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->gdbox,p,x,y,w,XXh,"gd off");
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->snbox,p,x,y,w,XXh,"sn    0");
zwogcam.c:    sprintf(buf,"px  %03d",(int)my_round(1000.0*g->px,0));
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->pxbox,p,x,y,w,XXh,buf);
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->pabox,p,x+d,y,w-d,XXh,"    0");
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->pabox,p,x,y,w,XXh,"pa    0");
zwogcam.c:    x += g->gdbox.w + PXw/2;
zwogcam.c:    y  = g->gdbox.y;
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->gmbox,p,x,y,w,XXh,"gm");
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->gabox,p,x,y,w,XXh,"ga  1");
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->fmbox,p,x,y,w,XXh,"fm  1");
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->mmbox,p,x,y,w,XXh,"mm  0");
zwogcam.c:    y = g->gmbox.y;
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->csbox,p,x,y,w,XXh,"Stp=1.0");
zwogcam.c:    x = g->csbox.x - w - PXw/2;
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->bxbox,p,x,y,w,XXh,"");
zwogcam.c:    y = g->dybox.y+XXh+3;
zwogcam.c:    g->g_tc = graph_create(&mwin,g->win,fontname,"tc",x,y,w,h,1,d);
zwogcam.c:    graph_scale(g->g_tc,0,10000,0);
zwogcam.c:    g->g_fw = graph_create(&mwin,g->win,fontname,"fw",x,y,w,h,1,d);
zwogcam.c:    graph_scale(g->g_fw,0.0,2.0,0);
zwogcam.c:    g->g_az = graph_create(&mwin,g->win,fontname,"AZ",x,y,w,h,1,d);
zwogcam.c:    graph_scale(g->g_az,-1.0,1.0,0x01);
zwogcam.c:    g->g_el = graph_create(&mwin,g->win,fontname,"EL",x,y,w,h,1,d);
zwogcam.c:    graph_scale(g->g_el,-1.0,1.0,0x01);
zwogcam.c:    sprintf(buf,"%.2f",g->status.exptime);
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->tfbox,g->win,1+2*PXw,y,9*PXw/2,XXh,buf);
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->avbox,g->win,
zwogcam.c:                             g->tfbox.x+g->tfbox.w+3*PXw,  y,3*PXw,XXh,"0");
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->dtbox,g->win,
zwogcam.c:                             g->avbox.x+g->avbox.w+6*PXw,  y,3*PXw,XXh,"-");
zwogcam.c:    sprintf(buf,"%d",g->sendNumber-1); 
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->sqbox,g->win,
zwogcam.c:                             g->dtbox.x+g->dtbox.w+1*PXw,  y,5*PXw,XXh,buf);
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->fgbox,g->win,
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->fdbox,g->win,
zwogcam.c:                             g->fgbox.x-g->fgbox.w-1*PXw,y,w,XXh,"0");
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->fpbox,g->win,
zwogcam.c:                             g->fdbox.x-g->fdbox.w-1*PXw,y,w,XXh,"0");
zwogcam.c:    w  = g->fpbox.x-2*PXw-1;                          /* v0313 */
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->cmbox,g->win,1,y,w,XXh,"_");
zwogcam.c:    CBX_WindowBorder_Ext(mwin.disp,g->cmbox.win,app->green);
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->tmbox,g->win,
zwogcam.c:                             g->fdbox.x,y,g->fgbox.w,XXh,"");
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->cpbox,g->win,  /* v0313 */
zwogcam.c:                             g->fgbox.x,y,g->fgbox.w,XXh,"");
zwogcam.c:    w  = g->fpbox.x+g->fpbox.w-x;
zwogcam.c:    g->msbox = (EditWindow*)malloc(n_msg*sizeof(EditWindow));
zwogcam.c:    g->led   = (Led*)malloc(n_msg*sizeof(Led));
zwogcam.c:      CBX_CreateAutoOutput_Ext(&mwin,&g->msbox[j],g->win,x+d,y,w-d,XXh,NULL);
zwogcam.c:      CBX_CreateLed_Ext(&mwin,&g->led[j],g->win,x+2,y+4,PXw,PXw,app->lgrey); 
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->gnbox,g->win,x,y,w,XXh,"gain");
zwogcam.c:    CBX_CreateAutoOutput_Ext(&mwin,&g->smbox,g->win,x,y,w,XXh,"sm       0");
zwogcam.c:    y = (vertical) ? g->tfbox.y-baseI-6 : 2;
zwogcam.c:    g->qltool = qltool_create(&mwin,g->win,fontname,
zwogcam.c:                              g->bxbox.x,g->bxbox.y+XXh+PXh/3,
zwogcam.c:                              g->smbox.x,g->msbox[0].y,g->smbox.w, 
zwogcam.c:                              g->status.dimx);
zwogcam.c:    g->qltool->gmode = g->gmode;
zwogcam.c:    if (g->lmag > 0) g->qltool->lmag = g->lmag;  /* overwrite v0415 */
zwogcam.c:    if (g->pct  > 0) { sprintf(buf,"%d",g->pct); qltool_scale(g->qltool,"pct",buf,""); }
zwogcam.c:    if (g->bkg  > 0) { sprintf(buf,"%d",g->bkg); qltool_scale(g->qltool,"bkg",buf,""); }
zwogcam.c:    if (g->span > 0) { sprintf(buf,"%d",g->span); qltool_scale(g->qltool,"spa",buf,""); }
zwogcam.c:    if (g->bx   > 0) { sprintf(buf,"bx %d",g->bx); handle_command(g,buf,0); }
zwogcam.c:    else sprintf(g->bxbox.text,"bx %2d",1+2*g->qltool->vrad);
zwogcam.c:    // CBX_SendExpose_Ext(mwin.disp,g->win);
zwogcam.c:    set_sens(g,g->sens);               /* guider sensitivity */
zwogcam.c:    set_gm  (g,g->gmode,0);
zwogcam.c:    assert(g->server);
zwogcam.c:    if (g->server) thread_detach(run_init,g);
zwogcam.c:      float x = g->qltool->curx[j];
zwogcam.c:      float y = g->qltool->cury[j];
zwogcam.c:      eds_send82i(g->gnum,1+j,x,y);
zwogcam.c:          if (event.xexpose.window == g->win) { 
zwogcam.c:          if (qltool_event(g->qltool,&event)) break;
zwogcam.c:          if (graph_event(g->g_tc,&event)) break;
zwogcam.c:          if (graph_event(g->g_fw,&event)) break;
zwogcam.c:          if (graph_event(g->g_az,&event)) break;
zwogcam.c:          if (graph_event(g->g_el,&event)) break;
zwogcam.c:        if (event.xkey.window == g->win) { 
zwogcam.c:          int b = cursor_blocked(g,g->qltool->cursor_mode,0);
zwogcam.c:          if (qltool_handle_key(g->qltool,(XKeyEvent*)&event,b)) {
zwogcam.c:              int c = g->qltool->cursor_mode;
zwogcam.c:              float x = g->qltool->curx[c];
zwogcam.c:              float y = g->qltool->cury[c];
zwogcam.c:              eds_send82i(g->gnum,1+c,x,y); /* v0346 */
zwogcam.c:          if (g->init_flag != 1) continue;
zwogcam.c:          if (event.xbutton.window == g->qltool->iwin) {
zwogcam.c:    if (g->server) zwo_free(g->server);
zwogcam.c:  Window  win=g->win;
zwogcam.c:  fprintf(stderr,"%s(%p): pa=%.1f, para=%.1f\n",PREFUN,g,g->pa,para);
zwogcam.c:  assert(g->pa != 0);
zwogcam.c:  XClearWindow(mwin.disp,g->win);
zwogcam.c:  x = g->gdbox.x+g->gdbox.w/2;
zwogcam.c:  y = g->dybox.y - PXh/4;
zwogcam.c:  g->north = sim_north = g->parity*(-fabs(g->pa) + para);  /* N/E */
zwogcam.c:  if (g->parity > 0) east  = g->north + ((g->pa > 0) ? 90.0 : -90.0);
zwogcam.c:  else               east  = g->north + ((g->pa < 0) ? 90.0 : -90.0);
zwogcam.c:  draw_compass(g,x,y,r,g->north,east,app->green); 
zwogcam.c:  x = g->gmbox.x+g->gmbox.w/2;
zwogcam.c:  double north = -fabs(g->pa) * g->parity;        /* az,el */
zwogcam.c:  if (g->parity > 0) east  = north + ((g->pa < 0) ? 90.0 : -90.0);
zwogcam.c:  else               east  = north + ((g->pa > 0) ? 90.0 : -90.0);
zwogcam.c:  Window  win=g->win;
zwogcam.c:  fprintf(stderr,"%s(%s)\n",PREFUN,g->name);
zwogcam.c:  XDrawString(disp,win,gc,g->tfbox.x-2*PXw,g->tfbox.y+PXh,"tf",2);
zwogcam.c:  XDrawString(disp,win,gc,g->avbox.x-2*PXw,g->avbox.y+PXh,"av",2);
zwogcam.c:  XDrawString(disp,win,gc,g->dtbox.x-4*PXw,g->dtbox.y+PXh,"send",4);
zwogcam.c:  XDrawString(disp,win,gc,g->fpbox.x-3*PXw,g->fpbox.y+PXh,"FpS",3);
zwogcam.c:  XDrawString(disp,win,gc,g->tmbox.x-4*PXw,g->tmbox.y+PXh,"Temp",4);
zwogcam.c:    if (g->qltool->cursor_mode == j) XSetForeground(disp,gc,app->green);
zwogcam.c:    x = g->qltool->cubox[j].x-PXw;
zwogcam.c:    y = g->qltool->cubox[j].y+PXh;
zwogcam.c:    if (g->qltool->cursor_mode == j) XSetForeground(disp,gc,app->black);
zwogcam.c:  if (g->pamode) XSetForeground(disp,gc,app->green);
zwogcam.c:  XDrawString(disp,win,gc,g->pabox.x-2*PXw-PXw/2,g->pabox.y+PXh,"pa",2);
zwogcam.c:  if (g->pamode) XSetForeground(disp,gc,app->black);
zwogcam.c:  sprintf(g->csbox.text,"Stp=%.1f",g->qltool->cursor_step);
zwogcam.c:  CBX_UpdateEditWindow(&g->csbox);
zwogcam.c:      int wait = (g->gmode == GM_SV5) ? 5 : 30; /* if not guiding v0420 */
zwogcam.c:      if ((!g->qltool->guiding) && (ut_now-pa_last < wait)) continue;
zwogcam.c:      if (g->pamode) {
zwogcam.c:    float file_system = checkfs(g->status.datapath); 
zwogcam.c:    g->qltool->flip_x = 1-g->qltool->flip_x;
zwogcam.c:    opmenu.entry[OPT_FLIP_X].flag = (g->qltool->flip_x) ? CBX_CHECKED : 0;
zwogcam.c:    qltool_redraw(g->qltool,False);
zwogcam.c:    g->qltool->flip_y = 1-g->qltool->flip_y;
zwogcam.c:    opmenu.entry[OPT_FLIP_Y].flag = (g->qltool->flip_y) ? CBX_CHECKED : 0;
zwogcam.c:    qltool_redraw(g->qltool,False);
zwogcam.c:  fprintf(stderr,"%s(%s)\n",PREFUN,g->name);
zwogcam.c:  if (g->init_flag != 1) return -E_NOTINIT;
zwogcam.c:  if (!g->loop_running) { 
zwogcam.c:      if (!g->loop_running) msleep(350);
zwogcam.c:  fprintf(stderr,"%s(%s)\n",PREFUN,g->name);
zwogcam.c:  if (g->loop_running) {
zwogcam.c:    if (g->qltool->guiding) { g->qltool->guiding = 0; msleep(350); } 
zwogcam.c:    g->stop_flag = True;
zwogcam.c:      if (g->loop_running) msleep(350);
zwogcam.c:  switch (g->msmode) {       /* mouse mode */
zwogcam.c:    qltool_cursor_set(g->qltool,QLT_BOX,x,y,r);
zwogcam.c:    if (g->msmode > 0) sprintf(buf,"probe-%d offset (%.1f)",g->gmode,r);
zwogcam.c:      if (g->pamode) err = set_pa(g,g->pa,1);
zwogcam.c:        qltool_cursor_off(g->qltool,QLT_BOX,x,y,r,&dx,&dy);
zwogcam.c:        rotate(g->px*dx,g->px*dy,g->pa,g->parity,&da,&de);
zwogcam.c:        if (!err && (g->msmode < 0)) err = telio_aeg(da,de);
zwogcam.c:      if (g->pamode) err = set_pa(g,g->pa,1);
zwogcam.c:        qltool_cursor_off(g->qltool,QLT_BOX,x,y,r,&dx,&dy);
zwogcam.c:        rotate(g->px*dx,g->px*dy,g->pa,g->parity,&da,&de);
zwogcam.c:    fprintf(stderr,"%s: invalid mouse mode %d\n",P_TITLE,g->msmode);
zwogcam.c:      if (g->qltool->cursor_step == steps[i]) break;
zwogcam.c:      if (steps[i+1] != 0) g->qltool->cursor_step = steps[i+1];
zwogcam.c:      if (steps[i-1] != 0) g->qltool->cursor_step = steps[i-1];
zwogcam.c:        g->qltool->cursor_mode = atoi(keys)-1;
zwogcam.c:        qltool_redraw(g->qltool,False);
zwogcam.c:    if (g->cmbox.cpos > 0) {           /* remove '_' */
zwogcam.c:      g->cmbox.cpos--; g->cmbox.text[g->cmbox.cpos] = '\0'; 
zwogcam.c:    int flag = CBX_HandleEditWindow(&g->cmbox,(XKeyEvent*)event);
zwogcam.c:      if (strlen(g->cmbox.text) > 0) {
zwogcam.c:        handle_command(g,g->cmbox.text,1);
zwogcam.c:        strcpy(g->cmbox.text,"");
zwogcam.c:        CBX_ResetEditWindow(&g->cmbox);
zwogcam.c:        // IDEA g->cmbox.cpos = 1; strcpy(g->cmbox.text,"_");
zwogcam.c:      g->cmbox.cpos += 1; strcat(g->cmbox.text,"_");
zwogcam.c:      CBX_UpdateEditWindow(&g->cmbox);
zwogcam.c:  fprintf(stderr,"%s(%s,%s)\n",PREFUN,g->name,command);
zwogcam.c:  msgstr = g->command_msg; *msgstr = '\0';  /* clear return v0333 */
zwogcam.c:    handle_command(g,g->lastCommand,showMsg);
zwogcam.c:      g->pamode = 1; pa_interval = imax(2,imin(120,atoi(par1))); /* v0420 */
zwogcam.c:      g->pamode = (g->pamode) ? 0 : 1;
zwogcam.c:    if (g->pamode) set_pa(g,g->pa,1);  /* get posAngle from TCS */
zwogcam.c:    g->pabox.fg = (g->pamode) ? app->green : app->black;
zwogcam.c:    CBX_UpdateEditWindow(&g->pabox);
zwogcam.c:    if (n >= 2) g->qltool->vrad = imax(7,(atoi(par1)-1)/2);
zwogcam.c:    sprintf(msgstr,"%d",1+2*g->qltool->vrad); 
zwogcam.c:    sprintf(g->bxbox.text,"bx %2d",1+2*g->qltool->vrad); // bug-fix v0408
zwogcam.c:    CBX_UpdateEditWindow(&g->bxbox);
zwogcam.c:    if (g->loop_running) do_stop(g,5000);
zwogcam.c:    zwo_close(g->server);
zwogcam.c:    g->init_flag = 0;
zwogcam.c:    if (g->fmode == 1) {               /* fm1 */
zwogcam.c:      g->qltool->guiding = 0;
zwogcam.c:      if (g->gid) { pthread_join(g->gid,NULL); g->gid = 0; }
zwogcam.c:      sprintf(g->gdbox.text,"gd  off"); CBX_UpdateEditWindow(&g->gdbox);
zwogcam.c:    if (g->fmode == 2) {               /* fm2 v0329 */
zwogcam.c:      if (g->stored_mode == 3) {       /* v0330 */
zwogcam.c:        g->stored_tf3 = g->server->expTime; /* store 'F3' values */
zwogcam.c:        g->stored_av = g->server->rolling;
zwogcam.c:        g->stored_send = g->send_flag;
zwogcam.c:        set_exptime(g,g->stored_tf1);
zwogcam.c:      g->stored_mode = 1;
zwogcam.c:    if (g->loop_running) {             /* implies (init_flag==1) */
zwogcam.c:      g->qltool->guiding = -2;
zwogcam.c:      if (!g->gid) thread_create(run_guider,g,&g->gid);
zwogcam.c:      sprintf(g->gdbox.text,"gd calc"); CBX_UpdateEditWindow(&g->gdbox);
zwogcam.c:    if (g->fmode == 1) {               /* fm1 */
zwogcam.c:      if (g->loop_running) {           /* implies (init_flag==1) */
zwogcam.c:        g->qltool->guiding = -3;
zwogcam.c:        if (!g->gid) thread_create(run_guider,g,&g->gid); 
zwogcam.c:        sprintf(g->gdbox.text,"gd move"); CBX_UpdateEditWindow(&g->gdbox);
zwogcam.c:    if (g->fmode == 2) {               /* fm2 v0329 */
zwogcam.c:      if (g->stored_mode == 1) {       /* v0330 */
zwogcam.c:        g->stored_tf1 = g->server->expTime; /* store 'F1' values */
zwogcam.c:        set_exptime(g,g->stored_tf3);       /* set 'F3' values */
zwogcam.c:        set_av(g,g->stored_av);
zwogcam.c:        set_sf(g,g->stored_send);
zwogcam.c:      g->stored_mode = 3;
zwogcam.c:    if (g->loop_running) {             /* implies (init_flag==1) */
zwogcam.c:      g->qltool->guiding = -4;
zwogcam.c:      if (!g->gid) thread_create(run_guider,g,&g->gid);
zwogcam.c:      sprintf(g->gdbox.text,"gd calc"); CBX_UpdateEditWindow(&g->gdbox);
zwogcam.c:    if (g->loop_running) {             /* implies (init_flag==1) */
zwogcam.c:      g->qltool->guiding = -5;
zwogcam.c:      if (!g->gid) thread_create(run_guider,g,&g->gid);
zwogcam.c:      sprintf(g->gdbox.text,"gd move"); CBX_UpdateEditWindow(&g->gdbox);
zwogcam.c:    sprintf(buf,"gpfld%d",g->gnum);    /* bug-fix v0418 */
zwogcam.c:    sprintf(buf,"gpsha%d",g->gnum);    /* bug-fix v0418 */
zwogcam.c:      if (g->qltool->guiding) {        /* not while guiding v0349 */
zwogcam.c:      if (g->qltool->guiding) {
zwogcam.c:        g->parit2 = (atof(par1) < 0) ? -1.0 : +1.0;
zwogcam.c:    sprintf(msgstr,"%+.0f",g->parit2);
zwogcam.c:    if (n > 1) g->px = fmax(0.001,atof(par1)/1000.0); /* v0415 */
zwogcam.c:    int px = (int)my_round(1000.0*g->px,0);
zwogcam.c:    sprintf(g->pxbox.text,(px >= 1000) ? "px %d" : "px  %03d",px);
zwogcam.c:    CBX_UpdateEditWindow(&g->pxbox);
zwogcam.c:    if (g->init_flag == 1) {
zwogcam.c:      g->send_flag = (n > 1) ? atoi(par1) : -1;  /* -1: single send */
zwogcam.c:      set_sf(g,g->send_flag);
zwogcam.c:    if (n > 1) g->shmode = atoi(par1); /* just a flag in the FITS header */
zwogcam.c:    qltool_scale(g->qltool,cmd,par1,par2);
zwogcam.c:      err = zwo_temperature(g->server,par1); 
zwogcam.c:        g->house_running = False;
zwogcam.c:        strcpy(g->cpbox.text,"");      /* v0313 */
zwogcam.c:        CBX_UpdateEditWindow(&g->cpbox);
zwogcam.c:      err = zwo_temperature(g->server,NULL); 
zwogcam.c:      sprintf(buf,"temp=%.1f setp=%.0f cooler=%.0f",g->server->tempSensor,
zwogcam.c:        g->server->tempSetpoint,g->server->coolerPercent); 
zwogcam.c:      g->qltool->cursor_mode = j;      /* make active */
zwogcam.c:        g->qltool->curx[j] = (float)atof(par2);
zwogcam.c:        g->qltool->cury[j] = (float)atof(par3);
zwogcam.c:        g->qltool->cursor_mode = j;    /* make active */
zwogcam.c:      if (!cursor_blocked(g,g->qltool->cursor_mode,1)) {
zwogcam.c:        g->qltool->curx[g->qltool->cursor_mode] = (float)atof(par1);
zwogcam.c:        g->qltool->cury[g->qltool->cursor_mode] = (float)atof(par2);
zwogcam.c:      qltool_redraw(g->qltool,False);
zwogcam.c:      float x = g->qltool->curx[g->qltool->cursor_mode];
zwogcam.c:      float y = g->qltool->cury[g->qltool->cursor_mode];
zwogcam.c:      eds_send82i(g->gnum,1+g->qltool->cursor_mode,x,y); /* v0347 */
zwogcam.c:        g->qltool->curx[j] += (float)atof(par2);
zwogcam.c:        g->qltool->cury[j] += (float)atof(par3);
zwogcam.c:        g->qltool->cursor_mode = j;    /* make active */
zwogcam.c:      if (!cursor_blocked(g,g->qltool->cursor_mode,1)) {
zwogcam.c:        g->qltool->curx[g->qltool->cursor_mode] += (float)atof(par1);
zwogcam.c:        g->qltool->cury[g->qltool->cursor_mode] += (float)atof(par2);
zwogcam.c:      qltool_redraw(g->qltool,False);
zwogcam.c:      float x = g->qltool->curx[g->qltool->cursor_mode];
zwogcam.c:      float y = g->qltool->cury[g->qltool->cursor_mode];
zwogcam.c:      eds_send82i(g->gnum,1+g->qltool->cursor_mode,x,y); /* v0347 */
zwogcam.c:    if (*par1) qltool_lmag(g->qltool,atoi(par1));
zwogcam.c:    else       sprintf(msgstr,"%d",g->qltool->lmag);
zwogcam.c:    if (n >= 2) qltool_lut(g->qltool,par1);
zwogcam.c:    if (!strcmp(par1,"dark")) g->qltool->cursor_dark = 1;
zwogcam.c:    else                      g->qltool->cursor_dark = 0;
zwogcam.c:    qltool_scale(g->qltool,par1,par2,par3);
zwogcam.c:    g->qltool->smoothing = abs(atoi(par1));
zwogcam.c:    sprintf(g->smbox.text,"sm %7d",g->qltool->smoothing);
zwogcam.c:    CBX_UpdateEditWindow(&g->smbox);
zwogcam.c:    if (*par1) g->slitW = imax(0,atoi(par1));
zwogcam.c:    if (*par1) g->slitW = imax(1,atoi(par1));
zwogcam.c:    else       sprintf(msgstr,"%d",g->slitW);
zwogcam.c:    g->write_flag = (n > 1) ? atoi(par1) : 1;
zwogcam.c:    if (g->init_flag >= 0) thread_detach(run_init,g);
zwogcam.c:    if (g->loop_running) do_stop(g,3000);
zwogcam.c:    err = zwo_server(g->server,cmd,buf); /* shutdown requires 'root' at rPi */
zwogcam.c:    err = zwo_gain(g->server,gain,offs);
zwogcam.c:    sprintf(msgstr,"%d %d",g->server->gain,g->server->offset);
zwogcam.c:    sprintf(g->gnbox.text,"gain %5d",g->server->gain);
zwogcam.c:    CBX_UpdateEditWindow(&g->gnbox);
zwogcam.c:      double s2 = fmax(0.01,2.0*pow(atof(par2)/(g->px*2.35482),2.0));
zwogcam.c:      strcpy(g->lastCommand,command);
zwogcam.c:  fprintf(stderr,"%s(%p): %s\n",PREFUN,param,g->name);
zwogcam.c:  assert(g->server->handle >= 0);       /* connected */
zwogcam.c:  assert(g->server->tid == 0);
zwogcam.c:  g->init_flag = -1;                   /* init running */
zwogcam.c:  sprintf(buf,"%s (%d) - v%s",g->host,g->gnum,P_VERSION); // v0419
zwogcam.c:  sprintf(buf,"%s (%d) - v%s",g->server->modelName,g->gnum,P_VERSION);
zwogcam.c:  long err = zwo_setup(g->server,baseD,baseB,g->offx,g->offy);
zwogcam.c:    strcpy(g->status.instrument,g->server->modelName);
zwogcam.c:    strcpy(g->status.serial,g->server->serialNumber);
zwogcam.c:    assert(g->server->aoiW == baseD);
zwogcam.c:    assert(g->server->aoiH == baseD);
zwogcam.c:    g->status.binning = baseB;
zwogcam.c:    g->status.exptime = g->server->expTime;
zwogcam.c:    err = zwo_gain(g->server,-1,-1);   /* read back current gain */
zwogcam.c:    if (*g->gain) {
zwogcam.c:      sprintf(buf,"gain %s",g->gain);
zwogcam.c:      err = zwo_gain(g->server,-1,-1);
zwogcam.c:    sprintf(g->gnbox.text,"gain %5d",g->server->gain);
zwogcam.c:    CBX_UpdateEditWindow(&g->gnbox);
zwogcam.c:    if (!g->server->mask) { 
zwogcam.c:      int npix = g->server->aoiW * g->server->aoiH;
zwogcam.c:      g->server->mask = (char*)calloc(npix,sizeof(char)); 
zwogcam.c:    g->init_flag = 0;                  /* there's no redemption :-( */
zwogcam.c:    assert(g->server->err == err);
zwogcam.c:    g->init_flag = 1;
zwogcam.c:  fprintf(stderr,"%s(%p): %s\n",PREFUN,param,g->name);
zwogcam.c:  assert(g->server);
zwogcam.c:  g->init_flag = -1;                   /* init running */
zwogcam.c:  if (g->loop_running) {               /* wait for loop to finish */
zwogcam.c:  if (g->server->handle > 0) {
zwogcam.c:    zwo_close(g->server); msleep(500);
zwogcam.c:    err = zwo_open(g->server);
zwogcam.c:      sprintf(buf,"no connection to %s:%d",g->server->host,g->server->port);
zwogcam.c:      if (!strncmp(g->server->modelName,"-E",2)) {
zwogcam.c:        sprintf(buf,"'%s' not connected to ZWO",g->server->host);
zwogcam.c:  g->init_flag = (err) ? 0 : 1;
zwogcam.c:      if (g->pamode) err = set_pa(g,g->pa,1);
zwogcam.c:  assert(g->init_flag == 1);
zwogcam.c:  if (g->house_running) return (void*)0;
zwogcam.c:  g->house_running = True;
zwogcam.c:  sprintf(buf,"%.1f",g->server->tempSetpoint);
zwogcam.c:  zwo_temperature(g->server,buf);      /* define setpoint */
zwogcam.c:    if (g->init_flag != 1) break;      /* will be restarted at _setup */
zwogcam.c:    if (!g->house_running) break;      /* stopped */
zwogcam.c:    assert(g->server);
zwogcam.c:    if (g->server->handle < 0) break;  /* not connected */
zwogcam.c:    err = zwo_temperature(g->server,NULL);
zwogcam.c:      sprintf(g->tmbox.text,"%.1f",g->server->tempSensor); 
zwogcam.c:      CBX_UpdateEditWindow(&g->tmbox);
zwogcam.c:      sprintf(g->cpbox.text,"%.0f%%",g->server->coolerPercent);
zwogcam.c:      CBX_UpdateEditWindow(&g->cpbox); /* v0313 */
zwogcam.c:      sprintf(buf,"temp=%.1f cooler=%.0f",g->server->tempSensor,
zwogcam.c:                                          g->server->coolerPercent); 
zwogcam.c:      if (fabs(g->server->tempSensor-g->server->tempSetpoint) > 0.2) {
zwogcam.c:  } while (g->house_running);          /* v0313 */
zwogcam.c:  if (g->house_running) sprintf(buf,"temperature stabilized");
zwogcam.c:  g->house_running = False;
zwogcam.c:  st->temp_ccd = g->server->tempSensor;   /* v0313 */
zwogcam.c:  st->shmode = g->shmode;                 /* v0316 */
zwogcam.c:  st->frame = g->sendNumber;              /* v0317 */
zwogcam.c:  ZwoStruct *server = g->server;
zwogcam.c:  assert(g->init_flag == 1);
zwogcam.c:  g->loop_running = True;
zwogcam.c:  g->stop_flag = False;
zwogcam.c:    while (!g->stop_flag) {
zwogcam.c:        sprintf(g->tmbox.text,"%.1f",g->server->tempSensor);
zwogcam.c:        CBX_UpdateEditWindow(&g->tmbox);
zwogcam.c:        sprintf(g->cpbox.text,"%.0f%%",g->server->coolerPercent);
zwogcam.c:        CBX_UpdateEditWindow(&g->cpbox); /* v0313 */
zwogcam.c:      if (g->send_flag) {
zwogcam.c:        cnt = g->send_flag - (tNow-tSend);
zwogcam.c:        sprintf(g->dtbox.text,"%d",(int)my_round(cnt,0));
zwogcam.c:        CBX_UpdateEditWindow(&g->dtbox);
zwogcam.c:        if ((g->send_flag) && (cnt <= 0.0)) { /* send frame */
zwogcam.c:          update_status(&g->status,g,frame);
zwogcam.c:            sock = TCPIP_CreateClientSocket(g->send_host,g->send_port,&err);
zwogcam.c:              err = fits_send(frame->data,&g->status,sock); /* network */
zwogcam.c:                 get_ut_timestr(buf,cor_time(0)),g->sendNumber,
zwogcam.c:                 g->send_host,g->send_port,err);
zwogcam.c:          sprintf(g->sqbox.text,"%u",g->sendNumber); /* v0343 */
zwogcam.c:          CBX_UpdateEditWindow(&g->sqbox);
zwogcam.c:          if (!err) g->sendNumber += 1;  // TODO ?Polivas overflow
zwogcam.c:          if (g->send_flag < 0) set_sf(g,0); /* single send */
zwogcam.c:        update_fps(&g->fpbox,g->server->fps);
zwogcam.c:      if (g->update_flag) {            /* update GUI from guider */
zwogcam.c:        pthread_mutex_lock(&g->mutex); /* lock and latch */
zwogcam.c:        double fps = g->fps;
zwogcam.c:        double flux = g->flux;
zwogcam.c:        double ppix = g->ppix;
zwogcam.c:        double back = g->back;
zwogcam.c:        double fwhm = g->fwhm;
zwogcam.c:        double dx = g->dx;
zwogcam.c:        double dy = g->dy;
zwogcam.c:        g->update_flag = False;
zwogcam.c:        pthread_mutex_unlock(&g->mutex);
zwogcam.c:        update_fps(&g->fgbox,fps);
zwogcam.c:          if (g->gmode != GM_SV3) {    /* {1,4,5} */
zwogcam.c:            if (flux>99999) sprintf(g->tcbox.text,"tc %4.0fk",flux/1000.0); // v0402
zwogcam.c:            else            sprintf(g->tcbox.text,"tc %5.0f",flux);
zwogcam.c:            CBX_UpdateEditWindow(&g->tcbox);
zwogcam.c:            sprintf(g->mxbox.text,"mx %5.0f",ppix);
zwogcam.c:            g->mxbox.fg = (ppix > 15000) ? app->red : app->black; /* v0411 */
zwogcam.c:            CBX_UpdateEditWindow(&g->mxbox);
zwogcam.c:            sprintf(g->bkbox.text,"bk %5.0f",back); 
zwogcam.c:            CBX_UpdateEditWindow(&g->bkbox);
zwogcam.c:            sprintf(g->fwbox.text,"fw %5.2f",fwhm);
zwogcam.c:            CBX_UpdateEditWindow(&g->fwbox);
zwogcam.c:          if (g->gmode == GM_SV3) sprintf(g->dxbox.text,"rx %5.2f",dx); // v0414
zwogcam.c:          else                    sprintf(g->dxbox.text,"dx %5.1f",dx);
zwogcam.c:          CBX_UpdateEditWindow(&g->dxbox);
zwogcam.c:          if (g->gmode == GM_SV3) sprintf(g->dybox.text,"ry %5.2f",dy);
zwogcam.c:          else                    sprintf(g->dybox.text,"dy %5.1f",dy);
zwogcam.c:          CBX_UpdateEditWindow(&g->dybox);
zwogcam.c:          graph_redraw(g->g_tc);
zwogcam.c:          graph_redraw(g->g_fw);
zwogcam.c:          graph_redraw(g->g_az);
zwogcam.c:          graph_redraw(g->g_el);
zwogcam.c:        if (q_flag != g->q_flag) {     /* quality flag */
zwogcam.c:          q_flag = g->q_flag;
zwogcam.c:            case 0: g->gdbox.fg = app->black; break;
zwogcam.c:            case 1: g->gdbox.fg = app->yellow; break;
zwogcam.c:            case 2: g->gdbox.fg = app->red; break;
zwogcam.c:          CBX_UpdateEditWindow(&g->gdbox);
zwogcam.c:  g->loop_running = False;
zwogcam.c:  sprintf(g->fpbox.text,"%d",0); CBX_UpdateEditWindow(&g->fpbox);
zwogcam.c:  sprintf(g->dtbox.text,"-"); CBX_UpdateEditWindow(&g->dtbox);
zwogcam.c:  QlTool *qltool = g->qltool;
zwogcam.c:  ZwoStruct *server = g->server;
zwogcam.c:  assert(g->init_flag == 1);
zwogcam.c:  int gx = g->status.dimx;
zwogcam.c:  int gy = g->status.dimy;
zwogcam.c:  while (g->loop_running) {
zwogcam.c:      update_fps(&g->fdbox,fps);
zwogcam.c:    slpt = fmax(0.02,fmin(tmax,fmax(slpt,g->status.exptime/3.0)));
zwogcam.c:  sprintf(g->fdbox.text,"%d",0); CBX_UpdateEditWindow(&g->fdbox);
zwogcam.c:  ZwoStruct *server = g->server;
zwogcam.c:  FITSpars *st = &g->status;
zwogcam.c:  if (g->init_flag != 1) return (void*)0;
zwogcam.c:  if (!g->loop_running) {
zwogcam.c:  while (g->loop_running) {
zwogcam.c:        sprintf(buf,FMT_RUN,g->gnum);
zwogcam.c:      g->write_flag -= 1;
zwogcam.c:    if (g->write_flag <= 0) break;
zwogcam.c:  ZwoStruct *server = g->server;
zwogcam.c:  if (g->offx || g->offy) {            /* v0348 */
zwogcam.c:            server->aoiW,g->offx,g->offy);
zwogcam.c:  ZwoStruct *server = g->server;
zwogcam.c:  ZwoStruct *server = g->server;
zwogcam.c:    if (g->rosign) err = telio_geo(NULL,NULL,&re ,NULL,&el,&pa); 
zwogcam.c:      f = g->angle + g->elsign*el + g->rosign*re;  /* v0311 */
zwogcam.c:  g->pa = f;
zwogcam.c:  sprintf(g->pabox.text,"pa %4.0f",my_round(g->pa,0));
zwogcam.c:  g->pabox.fg = (g->pamode) ? app->green : app->black;
zwogcam.c:  CBX_UpdateEditWindow(&g->pabox);
zwogcam.c:  fprintf(stderr,"%s(%s,%f)\n",PREFUN,g->name,f);
zwogcam.c:  g->sens = fmin(4.0,fmax(0.1,f));
zwogcam.c:  sprintf(g->snbox.text,"sn %4.1f",g->sens);
zwogcam.c:  CBX_UpdateEditWindow(&g->snbox);
zwogcam.c: switch (g->gmode) {
zwogcam.c:      g->msmode = m;
zwogcam.c:      g->msmode = m;
zwogcam.c:  if (g->msmode != m) {
zwogcam.c:  sprintf(g->mmbox.text,"mm %2d",g->msmode);
zwogcam.c:  CBX_UpdateEditWindow(&g->mmbox);
zwogcam.c:    g->fmode = m;
zwogcam.c:  if (g->fmode != m) { 
zwogcam.c:  sprintf(g->fmbox.text,"fm %2d",g->fmode);
zwogcam.c:  CBX_UpdateEditWindow(&g->fmbox);
zwogcam.c:  g->server->rolling = imax(0,imin(99,a));
zwogcam.c:  sprintf(g->avbox.text,"av %d",g->server->rolling);
zwogcam.c:  sprintf(g->avbox.text,"%d",g->server->rolling);
zwogcam.c:  CBX_UpdateEditWindow(&g->avbox);
zwogcam.c:  g->send_flag = s;
zwogcam.c:  if (s) sprintf(g->dtbox.text,"%d",imax(0,s));
zwogcam.c:  else    strcpy(g->dtbox.text,"-");
zwogcam.c:  CBX_UpdateEditWindow(&g->dtbox);
zwogcam.c:  g->gmode = imax(1,imin(GM_MAX,m));
zwogcam.c:  if (c) g->gmpar = (c == 'p') ? 'p' : 't';
zwogcam.c:  switch (g->gmode) {                  /* v0416 */
zwogcam.c:    sprintf(g->gmbox.text,"gm %1d%c",g->gmode,g->gmpar);
zwogcam.c:    sprintf(g->gmbox.text,"gm %2d",g->gmode);
zwogcam.c:  CBX_UpdateEditWindow(&g->gmbox);
zwogcam.c:  g->qltool->gmode = g->gmode;
zwogcam.c:  switch (g->gmode) {                  /* v0414 */
zwogcam.c:    strcpy(g->g_tc->name,"tc"); graph_scale(g->g_fw,0,10000,0);
zwogcam.c:    strcpy(g->g_fw->name,"fw"); graph_scale(g->g_fw,0.0,2.0,0);
zwogcam.c:    strcpy(g->g_az->name,"AZ"); graph_scale(g->g_az,-1.0,1.0,0x01);
zwogcam.c:    strcpy(g->g_el->name,"EL"); graph_scale(g->g_el,-1.0,1.0,0x01);
zwogcam.c:    strcpy(g->g_tc->name,"rx"); graph_scale(g->g_tc,-0.5,0.5,0x03);
zwogcam.c:    strcpy(g->g_fw->name,"ry"); graph_scale(g->g_fw,-0.5,0.5,0x03);
zwogcam.c:    strcpy(g->g_az->name,"AZ"); graph_scale(g->g_az,-1.0,1.0,0x01);
zwogcam.c:    strcpy(g->g_el->name,"EL"); graph_scale(g->g_el,-1.0,1.0,0x01);
zwogcam.c:    strcpy(g->g_tc->name,"tc"); graph_scale(g->g_fw,0,10000,0);
zwogcam.c:    strcpy(g->g_fw->name,"fw"); graph_scale(g->g_fw,0.0,2.0,0);
zwogcam.c:    strcpy(g->g_az->name,"X");  graph_scale(g->g_az,-1.0,1.0,0x03);
zwogcam.c:    strcpy(g->g_el->name,"Y");  graph_scale(g->g_el,-1.0,1.0,0x03);
zwogcam.c:    double tmin = (g->server->aoiW*g->server->aoiH)/90.0e6;
zwogcam.c:    g->status.exptime = (float)fmin(MAX_EXPTIME,fmax(tmin,t));
zwogcam.c:  sprintf(g->tfbox.text,"%.*f",(g->status.exptime < 10) ? 2 : 1,
zwogcam.c:          g->status.exptime);
zwogcam.c:  CBX_ResetEditWindow(&g->tfbox);
zwogcam.c:    err = zwo_exptime(g->server,g->status.exptime);
zwogcam.c:      g->status.exptime = (float)g->server->expTime;
zwogcam.c:      // strcpy(who,(g) ? g->name : P_TITLE);
zwogcam.c:    sprintf(g->msbox[0].text,"%s: %s",tstr,text);
zwogcam.c:    CBX_UpdateEditWindow(&g->msbox[0]);
zwogcam.c:  for (i=n_msg-1; i>=0; i--) {         /* prepend line */
zwogcam.c:      sprintf(g->msbox[i].text,"%s: %s",tstr,text);
zwogcam.c:      if      (flags & MSS_RED)    CBX_ChangeLed(&g->led[i],app->red); 
zwogcam.c:      else if (flags & MSS_YELLOW) CBX_ChangeLed(&g->led[i],app->yellow); 
zwogcam.c:      else                         CBX_ChangeLed(&g->led[i],app->green); 
zwogcam.c:      strcpy(g->msbox[i].text,g->msbox[i-1].text);
zwogcam.c:      CBX_ChangeLed(&g->led[i],g->led[i-1].bg);
zwogcam.c:    CBX_UpdateEditWindow(&g->msbox[i]);
zwogcam.c:  if ((g->gmode == GM_SV5) && (g->qltool->guiding)) {
zwogcam.c:      if      (!strcmp(key,"host")) strcpy(g->host,val);
zwogcam.c:      else if (!strcmp(key,"port")) g->rPort = atoi(val); 
zwogcam.c:      else if (!strcmp(key,"gain")) strcpy(g->gain,val);
zwogcam.c:      else if (!strcmp(key,"gnum")) g->gnum = atoi(val);
zwogcam.c:      else if (!strcmp(key,"gmode")) g->gmode = atoi(val);
zwogcam.c:      else if (!strcmp(key,"gmpar")) g->gmpar = (int)val[0];
zwogcam.c:      else if (!strcmp(key,"angle")) g->angle = atof(val);
zwogcam.c:      else if (!strcmp(key,"elsign")) g->elsign = atof(val);
zwogcam.c:      else if (!strcmp(key,"rosign")) g->rosign = atof(val);
zwogcam.c:      else if (!strcmp(key,"parity")) g->parity = (atof(val) < 0) ? -1.0 : 1.0;
zwogcam.c:      else if (!strcmp(key,"offx")) g->offx = atoi(val);
zwogcam.c:      else if (!strcmp(key,"offy")) g->offy = atoi(val);
zwogcam.c:      else if (!strcmp(key,"px")) g->px = atof(val)/1000.0;
zwogcam.c:      else if (!strcmp(key,"lmag")) g->lmag = atoi(val);
zwogcam.c:      else if (!strcmp(key,"pct")) g->pct = atoi(val);
zwogcam.c:      else if (!strcmp(key,"bkg")) g->bkg = atoi(val);
zwogcam.c:      else if (!strcmp(key,"span")) g->span = atoi(val);
zwogcam.c:      else if (!strcmp(key,"bx")) g->bx = atoi(val);
zwogcam.c:      else if (!strcmp(key,"sw")) g->slitW = atoi(val); 
zwogcam.c:      else if (!strcmp(key,"sn")) g->sens = fmin(4.0,fmax(0.1,atof(val)));
zwogcam.c:      sprintf(answer,"-E%s",g->command_msg);
zwogcam.c:      if (*g->command_msg) strcpy(answer,g->command_msg);
zwogcam.c:  int    port = TCPIP_PORT + g->gnum;
zwogcam.c:  sprintf(buf,"TCPIP-Server listening (%s,%d)",g->name,port);
